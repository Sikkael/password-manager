{"version":3,"sources":["../src/Path.ts"],"names":["stringifyPath","path","join","equalPath","a","b","length","k","getParentPath","Error","slice","getChildPath","childPath","getPathLastSegment","getChildSafe","current","segment","Array","isArray","index","parseInt","Number","isInteger","undefined","Object","keys","includes","getAtPathSafe","obj","childFound","child","getAtPath","found","value","setAtPath","parentFound","parent","key","push","deleteAtPath","pop","matchPathPrefix","prefixPath","replacePathPrefix","prevPrefixPath","nextPrefixPath"],"mappings":";;;;;;;AAAA;;AAEO,MAAMA,aAAa,GAAIC,IAAD,IAA4BA,IAAI,CAACC,IAAL,CAAW,GAAX,CAAlD;;;;AAEA,MAAMC,SAAS,GAAG,CAACC,CAAD,EAAcC,CAAd,KAAuC;AAC9D,MAAID,CAAC,CAACE,MAAF,KAAaD,CAAC,CAACC,MAAnB,EAA2B;AACzB,WAAO,KAAP;AACD;;AACD,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACE,MAAtB,EAA8BC,CAAC,EAA/B,EAAmC;AACjC,QAAIH,CAAC,CAACG,CAAD,CAAD,KAASF,CAAC,CAACE,CAAD,CAAd,EAAmB;AACjB,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD,CAVM;;;;AAYP,MAAMC,aAAa,GAAsBP,IAAnB,IAAsC;AAC1D,MAAIA,IAAI,CAACK,MAAL,KAAgB,CAApB,EAAuB;AACrB,UAAM,IAAIG,KAAJ,CAAW,SAAQT,aAAa,CAACC,IAAD,CAAO,iBAAvC,CAAN;AACD;;AACD,SAAOA,IAAI,CAACS,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAP;AACD,CALD;;AAOO,MAAMC,YAAY,GAAG,CAC1BV,IAD0B,EAE1B,GAAGW,SAFuB,KAGlB,CAAC,GAAGX,IAAJ,EAAU,GAAGW,SAAb,CAHH;;;;AAKP,MAAMC,kBAAkB,GAAsBZ,IAAnB,IAAoC;AAC7D,MAAIA,IAAI,CAACK,MAAL,KAAgB,CAApB,EAAuB;AACrB,UAAM,IAAIG,KAAJ,CAAW,SAAQT,aAAc,iBAAjC,CAAN;AACD;;AACD,SAAOC,IAAI,CAACA,IAAI,CAACK,MAAL,GAAc,CAAf,CAAX;AACD,CALD;;AAOA,MAAMQ,YAAY,GAAG,CACnBC,OADmB,EAEnBC,OAFmB,KAGuB;AAC1C,MAAIC,KAAK,CAACC,OAAN,CAAcH,OAAd,CAAJ,EAA4B;AAC1B,UAAMI,KAAK,GAAGC,QAAQ,CAACJ,OAAD,CAAtB;;AACA,QAAI,CAACK,MAAM,CAACC,SAAP,CAAiBH,KAAjB,CAAL,EAA8B;AAC5B,YAAM,IAAIV,KAAJ,CACH,oCAAmCO,OAAQ,qBADxC,CAAN;AAGD;;AACD,QAAIG,KAAK,GAAG,CAAZ,EAAe;AACb,YAAM,IAAIV,KAAJ,CAAW,kCAAiCU,KAAM,eAAlD,CAAN;AACD;;AACD,WAAO,CAAC,OAAOJ,OAAO,CAACI,KAAD,CAAd,KAA0BI,SAA3B,EAAsCR,OAAO,CAACI,KAAD,CAA7C,CAAP;AACD;;AACD,MAAI,oBAASJ,OAAT,CAAJ,EAAuB;AACrB,WAAO,CAACS,MAAM,CAACC,IAAP,CAAYV,OAAZ,EAAqBW,QAArB,CAA8BV,OAA9B,CAAD,EAAyCD,OAAO,CAACC,OAAD,CAAhD,CAAP;AACD;;AACD,SAAO,CAAC,KAAD,EAAQO,SAAR,CAAP;AACD,CApBD;;AAsBO,MAAMI,aAAa,GAAG,CAC3BC,GAD2B,EAE3B3B,IAF2B,KAGe;AAC1C,MAAIc,OAAO,GAAGa,GAAd;;AAEA,OAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAAI,CAACK,MAAzB,EAAiCC,CAAC,EAAlC,EAAsC;AACpC,UAAM,CAACsB,UAAD,EAAaC,KAAb,IAAsBhB,YAAY,CAACC,OAAD,EAAUd,IAAI,CAACM,CAAD,CAAd,CAAxC;;AACA,QAAI,CAACsB,UAAL,EAAiB;AACf,UAAItB,CAAC,KAAKN,IAAI,CAACK,MAAL,GAAc,CAAxB,EAA2B;AACzB,cAAM,IAAIG,KAAJ,CACH,gBAAeT,aAAa,CAACC,IAAD,CAAO,+BAClCA,IAAI,CAACM,CAAD,CACL,GAHG,CAAN;AAKD;;AACD,aAAO,CAAC,KAAD,EAAQgB,SAAR,CAAP;AACD;;AACDR,IAAAA,OAAO,GAAGe,KAAV;AACD;;AACD,SAAO,CAAC,IAAD,EAAOf,OAAP,CAAP;AACD,CArBM;;;;AAuBA,MAAMgB,SAAS,GAAG,CAACH,GAAD,EAAe3B,IAAf,KAA2C;AAClE,QAAM,CAAC+B,KAAD,EAAQC,KAAR,IAAiBN,aAAa,CAACC,GAAD,EAAM3B,IAAN,CAApC;;AACA,MAAI,CAAC+B,KAAL,EAAY;AACV,UAAM,IAAIvB,KAAJ,CAAW,eAAcT,aAAa,CAACC,IAAD,CAAO,cAA7C,CAAN;AACD;;AACD,SAAOgC,KAAP;AACD,CANM;;;;AAQA,MAAMC,SAAS,GAAG,CACvBN,GADuB,EAEvB3B,IAFuB,EAGvBgC,KAHuB,KAId;AACT,QAAM,CAACE,WAAD,EAAcC,MAAd,IAAwBT,aAAa,CAACC,GAAD,EAAMpB,aAAa,CAACP,IAAD,CAAnB,CAA3C;;AACA,MAAI,CAACkC,WAAL,EAAkB;AAChB,UAAM,IAAI1B,KAAJ,CAAW,gBAAeT,aAAa,CAACC,IAAD,CAAO,cAA9C,CAAN;AACD;;AACD,QAAMoC,GAAG,GAAGxB,kBAAkB,CAACZ,IAAD,CAA9B;;AAEA,MAAIgB,KAAK,CAACC,OAAN,CAAckB,MAAd,CAAJ,EAA2B;AACzB,UAAMjB,KAAK,GAAGC,QAAQ,CAACiB,GAAD,CAAtB;;AACA,QAAI,CAAChB,MAAM,CAACC,SAAP,CAAiBH,KAAjB,CAAL,EAA8B;AAC5B,YAAM,IAAIV,KAAJ,CACH,aAAYT,aAAa,CAACC,IAAD,CAAO,WAAUoC,GAAI,sBAD3C,CAAN;AAGD;;AACD,QAAIlB,KAAK,GAAG,CAAZ,EAAe;AACb,YAAM,IAAIV,KAAJ,CACH,eAAcT,aAAa,CAACC,IAAD,CAAO,aAAYkB,KAAM,gBADjD,CAAN;AAGD;;AACD,QAAIA,KAAK,GAAGiB,MAAM,CAAC9B,MAAnB,EAA2B;AACzB,YAAM,IAAIG,KAAJ,CACH,eAAcT,aAAa,CAC1BC,IAD0B,CAE1B,aAAYkB,KAAM,qBAHhB,CAAN;AAKD;;AACD,QAAIA,KAAK,KAAKiB,MAAM,CAAC9B,MAArB,EAA6B;AAC3B8B,MAAAA,MAAM,CAACE,IAAP,CAAYL,KAAZ;AACD,KAFD,MAEO;AACLG,MAAAA,MAAM,CAACjB,KAAD,CAAN,GAAgBc,KAAhB;AACD;AACF,GAxBD,MAwBO,IAAI,oBAASG,MAAT,CAAJ,EAAsB;AAC3BA,IAAAA,MAAM,CAACC,GAAD,CAAN,GAAcJ,KAAd;AACD,GAFM,MAEA;AACL,UAAM,IAAIxB,KAAJ,CAAW,gBAAeR,IAAK,gCAA/B,CAAN;AACD;AACF,CAxCM;;;;AA0CA,MAAMsC,YAAY,GAAG,CAACX,GAAD,EAAe3B,IAAf,KAAwC;AAClE,QAAM,CAACkC,WAAD,EAAcC,MAAd,IAAwBT,aAAa,CAACC,GAAD,EAAMpB,aAAa,CAACP,IAAD,CAAnB,CAA3C;;AACA,MAAI,CAACkC,WAAL,EAAkB;AAChB,UAAM,IAAI1B,KAAJ,CAAW,gBAAeT,aAAa,CAACC,IAAD,CAAO,cAA9C,CAAN;AACD;;AACD,QAAMoC,GAAG,GAAGxB,kBAAkB,CAACZ,IAAD,CAA9B;;AAEA,MAAIgB,KAAK,CAACC,OAAN,CAAckB,MAAd,CAAJ,EAA2B;AACzB,UAAMjB,KAAK,GAAGC,QAAQ,CAACiB,GAAD,CAAtB;;AACA,QAAI,CAAChB,MAAM,CAACC,SAAP,CAAiBH,KAAjB,CAAL,EAA8B;AAC5B,YAAM,IAAIV,KAAJ,CACH,aAAYT,aAAa,CAACC,IAAD,CAAO,WAAUoC,GAAI,sBAD3C,CAAN;AAGD;;AACD,QAAIlB,KAAK,KAAKiB,MAAM,CAAC9B,MAArB,EAA6B;AAC3B,YAAM,IAAIG,KAAJ,CACH,eAAcT,aAAa,CAC1BC,IAD0B,CAE1B,aAAYkB,KAAM,8DAHhB,CAAN;AAKD;;AACDiB,IAAAA,MAAM,CAACI,GAAP;AACD,GAfD,MAeO,IAAI,oBAASJ,MAAT,CAAJ,EAAsB;AAC3B,QAAI,CAACZ,MAAM,CAACC,IAAP,CAAYW,MAAZ,EAAoBV,QAApB,CAA6BW,GAA7B,CAAL,EAAwC;AACtC,YAAM,IAAI5B,KAAJ,CACH,aAAYT,aAAa,CAACC,IAAD,CAAO,WAAUoC,GAAI,wBAD3C,CAAN;AAGD;;AACD,WAAOD,MAAM,CAACC,GAAD,CAAb;AACD,GAPM,MAOA;AACL,UAAM,IAAI5B,KAAJ,CACH,gBAAeT,aAAa,CAACC,IAAD,CAAO,gCADhC,CAAN;AAGD;AACF,CAlCM;;;;AAoCA,MAAMwC,eAAe,GAAG,CAC7BC,UAD6B,EAE7BzC,IAF6B,KAGjB;AACZ,MAAIA,IAAI,CAACK,MAAL,GAAcoC,UAAU,CAACpC,MAA7B,EAAqC;AACnC,WAAO,KAAP;AACD;;AACD,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,UAAU,CAACpC,MAA/B,EAAuCC,CAAC,EAAxC,EAA4C;AAC1C,QAAIN,IAAI,CAACM,CAAD,CAAJ,KAAYmC,UAAU,CAACnC,CAAD,CAA1B,EAA+B;AAC7B,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD,CAbM;;;;AAeA,MAAMoC,iBAAiB,GAAG,CAC/BC,cAD+B,EAE/BC,cAF+B,EAG/B5C,IAH+B,KAIvB;AACR,MAAI,CAACwC,eAAe,CAACG,cAAD,EAAiB3C,IAAjB,CAApB,EAA4C;AAC1C,UAAM,IAAIQ,KAAJ,CACH,SAAQT,aAAa,CACpBC,IADoB,CAEpB,mCAAkCD,aAAa,CAAC4C,cAAD,CAAiB,GAH9D,CAAN;AAKD;;AACD,SAAO,CAAC,GAAGC,cAAJ,EAAoB,GAAG5C,IAAI,CAACS,KAAL,CAAWkC,cAAc,CAACtC,MAA1B,CAAvB,CAAP;AACD,CAbM","sourcesContent":["import { isRecord } from \"./util\";\n\nexport const stringifyPath = (path: string[]): string => path.join(`/`);\n\nexport const equalPath = (a: string[], b: string[]): boolean => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let k = 0; k < a.length; k++) {\n    if (a[k] !== b[k]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst getParentPath = <T extends string>(path: T[]): T[] => {\n  if (path.length === 0) {\n    throw new Error(`path='${stringifyPath(path)}' has no parent`);\n  }\n  return path.slice(0, -1);\n};\n\nexport const getChildPath = <T extends string>(\n  path: T[],\n  ...childPath: T[]\n): T[] => [...path, ...childPath];\n\nconst getPathLastSegment = <T extends string>(path: T[]): T => {\n  if (path.length === 0) {\n    throw new Error(`path='${stringifyPath}' has no parent`);\n  }\n  return path[path.length - 1];\n};\n\nconst getChildSafe = (\n  current: unknown,\n  segment: string,\n): [childFound: boolean, value: unknown] => {\n  if (Array.isArray(current)) {\n    const index = parseInt(segment);\n    if (!Number.isInteger(index)) {\n      throw new Error(\n        `current is an array but segment='${segment}' is not an integer`,\n      );\n    }\n    if (index < 0) {\n      throw new Error(`current is an array but index='${index}' is negative`);\n    }\n    return [typeof current[index] !== undefined, current[index]];\n  }\n  if (isRecord(current)) {\n    return [Object.keys(current).includes(segment), current[segment]];\n  }\n  return [false, undefined];\n};\n\nexport const getAtPathSafe = (\n  obj: unknown,\n  path: string[],\n): [valueFound: boolean, value: unknown] => {\n  let current = obj;\n\n  for (let k = 0; k < path.length; k++) {\n    const [childFound, child] = getChildSafe(current, path[k]);\n    if (!childFound) {\n      if (k !== path.length - 1) {\n        throw new Error(\n          `parent(path='${stringifyPath(path)}') has no child at segment='${\n            path[k]\n          }'`,\n        );\n      }\n      return [false, undefined];\n    }\n    current = child;\n  }\n  return [true, current];\n};\n\nexport const getAtPath = (obj: unknown, path: string[]): unknown => {\n  const [found, value] = getAtPathSafe(obj, path);\n  if (!found) {\n    throw new Error(`value(path='${stringifyPath(path)}') not found`);\n  }\n  return value;\n};\n\nexport const setAtPath = (\n  obj: unknown,\n  path: string[],\n  value: unknown,\n): void => {\n  const [parentFound, parent] = getAtPathSafe(obj, getParentPath(path));\n  if (!parentFound) {\n    throw new Error(`parent(path='${stringifyPath(path)}') not found`);\n  }\n  const key = getPathLastSegment(path);\n\n  if (Array.isArray(parent)) {\n    const index = parseInt(key);\n    if (!Number.isInteger(index)) {\n      throw new Error(\n        `key(path='${stringifyPath(path)}', key='${key}') is not an integer`,\n      );\n    }\n    if (index < 0) {\n      throw new Error(\n        `index(path='${stringifyPath(path)}', index='${index}') is negative`,\n      );\n    }\n    if (index > parent.length) {\n      throw new Error(\n        `index(path='${stringifyPath(\n          path,\n        )}', index='${index}') is out of bounds`,\n      );\n    }\n    if (index === parent.length) {\n      parent.push(value);\n    } else {\n      parent[index] = value;\n    }\n  } else if (isRecord(parent)) {\n    parent[key] = value;\n  } else {\n    throw new Error(`parent(path='${path}') is not an Array or a Record`);\n  }\n};\n\nexport const deleteAtPath = (obj: unknown, path: string[]): void => {\n  const [parentFound, parent] = getAtPathSafe(obj, getParentPath(path));\n  if (!parentFound) {\n    throw new Error(`parent(path='${stringifyPath(path)}') not found`);\n  }\n  const key = getPathLastSegment(path);\n\n  if (Array.isArray(parent)) {\n    const index = parseInt(key);\n    if (!Number.isInteger(index)) {\n      throw new Error(\n        `key(path='${stringifyPath(path)}', key='${key}') is not an integer`,\n      );\n    }\n    if (index !== parent.length) {\n      throw new Error(\n        `index(path='${stringifyPath(\n          path,\n        )}', index='${index}') is invalid: only last item of parent array can be deleted`,\n      );\n    }\n    parent.pop();\n  } else if (isRecord(parent)) {\n    if (!Object.keys(parent).includes(key)) {\n      throw new Error(\n        `key(path='${stringifyPath(path)}', key='${key}') not found in parent`,\n      );\n    }\n    delete parent[key];\n  } else {\n    throw new Error(\n      `parent(path='${stringifyPath(path)}') is not an Array or a Record`,\n    );\n  }\n};\n\nexport const matchPathPrefix = (\n  prefixPath: readonly string[],\n  path: string[],\n): boolean => {\n  if (path.length < prefixPath.length) {\n    return false;\n  }\n  for (let k = 0; k < prefixPath.length; k++) {\n    if (path[k] !== prefixPath[k]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const replacePathPrefix = <T extends string>(\n  prevPrefixPath: T[],\n  nextPrefixPath: T[],\n  path: T[],\n): T[] => {\n  if (!matchPathPrefix(prevPrefixPath, path)) {\n    throw new Error(\n      `path='${stringifyPath(\n        path,\n      )}' doesn't match prevPrefixPath='${stringifyPath(prevPrefixPath)}'`,\n    );\n  }\n  return [...nextPrefixPath, ...path.slice(prevPrefixPath.length)];\n};\n"],"file":"Path.js"}