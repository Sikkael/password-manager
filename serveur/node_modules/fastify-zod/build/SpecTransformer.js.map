{"version":3,"sources":["../src/SpecTransformer.ts"],"names":["isRef","ref","$ref","toRefPath","indexOfPath","indexOf","basePath","slice","path","split","toRef","refPath","join","isSpecSchema","input","properties","additionalProperties","patternProperties","items","isSpecSchemas","value","Object","values","isOpenApiSpec","components","paths","schemas","isSwaggerSpec","definitions","isSpec","deepClone","spec","JSON","parse","stringify","defaultExtractSchemaPropertiesKey","withTimings","fn","begin","performance","now","result","end","delta","SpecTransformer","constructor","DEBUG","Error","schemasPath","initialSchemaKeys","getSchemaKeys","_DEBUG","args","console","debug","throw","error","depth","getSchemaPath","schemaKey","getSchema","schema","getAtPath","keys","createSchemaKey","parentSchemaKey","schemaKeysOptions","parts","removeInitialSchemasPrefix","includes","push","baseName","changeCase","getAtPathSafe","resolveRef","length","nextRef","setAtPath","deleteAtPath","findFirstDeep","predicate","hasProperRef","schemaPath","deleteUnusedSchemas","dirty","rewriteSchemaAbsoluteRefs","nextPath","rewriteSchemasAbsoluteRefs","extractSchemaPathAsSchema","prevSchemaKey","prevRelativePath","nextSchemaKey","prevPath","prevValue","hasValueAtNextPath","valueAtNextPath","extractSchemaPropertiesAtKey","propertiesKey","globalDirty","k","property","extractSchemaProperties","propertiesKeys","extractSchemasProperties","mergeRef","prev$ref","next$ref","mergeRefs","$refs","transformWithTimings","opts","total","map","extractSchemasPropertiesKeys","Array","isArray","schemaKeys","timings","transform"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AAEA;;AAUA;;;;AAMA,MAAMA,KAAK,GAAIC,GAAD,IAA8B;AAC1C,MAAI,CAAC,qBAASA,GAAT,CAAL,EAAoB;AAClB,WAAO,KAAP;AACD;;AACD,SAAO,OAAOA,GAAG,CAACC,IAAX,KAAqB,QAA5B;AACD,CALD;;AAYA,MAAMC,SAAS,GAAID,IAAD,IAA2B;AAC3C,QAAME,WAAW,GAAGF,IAAI,CAACG,OAAL,CAAc,GAAd,CAApB;AACA,SAAO;AACLC,IAAAA,QAAQ,EAAEJ,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcH,WAAd,CADL;AAELI,IAAAA,IAAI,EAAEN,IAAI,CACPK,KADG,CACGH,WAAW,GAAG,CADjB,EAEHK,KAFG,CAEI,GAFJ,EAGHF,KAHG,CAGG,CAHH;AAFD,GAAP;AAOD,CATD;;AAWA,MAAMG,KAAK,GAAIC,OAAD,KAA4B;AACxCT,EAAAA,IAAI,EAAE,CAAE,GAAES,OAAO,CAACL,QAAS,GAArB,EAAyB,GAAGK,OAAO,CAACH,IAApC,EAA0CI,IAA1C,CAAgD,GAAhD;AADkC,CAA5B,CAAd;;AAWA,MAAMC,YAAY,GAAIC,KAAD,IAAyC;AAC5D,MAAI,CAAC,qBAASA,KAAT,CAAL,EAAsB;AACpB,WAAO,KAAP;AACD;;AACD,QAAM;AAAEC,IAAAA,UAAF;AAAcC,IAAAA,oBAAd;AAAoCC,IAAAA,iBAApC;AAAuDC,IAAAA;AAAvD,MAAiEJ,KAAvE;;AACA,MAAI,OAAOC,UAAP,KAAuB,WAAvB,IAAqC,CAAC,qBAASA,UAAT,CAA1C,EAAgE;AAC9D,WAAO,KAAP;AACD;;AAED,MACE,OAAOC,oBAAP,KAAiC,WAAjC,IACA,OAAOA,oBAAP,KAAiC,SADjC,IAEA,CAAC,qBAASA,oBAAT,CAHH,EAIE;AACA,WAAO,KAAP;AACD;;AAED,MACE,OAAOC,iBAAP,KAA8B,WAA9B,IACA,OAAOA,iBAAP,KAA8B,SAD9B,IAEA,CAAC,qBAASA,iBAAT,CAHH,EAIE;AACA,WAAO,KAAP;AACD;;AAED,MAAI,OAAOC,KAAP,KAAkB,WAAlB,IAAgC,CAAC,qBAASA,KAAT,CAArC,EAAsD;AACpD,WAAO,KAAP;AACD;;AAED,SAAO,IAAP;AACD,CA9BD;;AAkCA,MAAMC,aAAa,GAAIL,KAAD,IAA0C;AAC9D,MAAI,CAAC,qBAASA,KAAT,CAAL,EAAsB;AACpB,WAAO,KAAP;AACD;;AACD,OAAK,MAAMM,KAAX,IAAoBC,MAAM,CAACC,MAAP,CAAcR,KAAd,CAApB,EAA0C;AACxC,QAAI,CAACD,YAAY,CAACO,KAAD,CAAjB,EAA0B;AACxB,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD,CAVD;;AAmBA,MAAMG,aAAa,GAAIT,KAAD,IAA0C;AAC9D,MAAI,CAAC,qBAASA,KAAT,CAAL,EAAsB;AACpB,WAAO,KAAP;AACD;;AACD,QAAM;AAAEU,IAAAA,UAAF;AAAcC,IAAAA;AAAd,MAAwBX,KAA9B;;AACA,MAAI,CAAC,qBAASU,UAAT,CAAL,EAA2B;AACzB,WAAO,KAAP;AACD;;AACD,QAAM;AAAEE,IAAAA;AAAF,MAAcF,UAApB;;AACA,MAAI,CAACL,aAAa,CAACO,OAAD,CAAlB,EAA6B;AAC3B,WAAO,KAAP;AACD;;AACD,MAAI,OAAOD,KAAP,KAAkB,WAAlB,IAAgC,CAAC,qBAASA,KAAT,CAArC,EAAsD;AACpD,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD,CAhBD;;AAuBA,MAAME,aAAa,GAAIb,KAAD,IAA0C;AAC9D,MAAI,CAAC,qBAASA,KAAT,CAAL,EAAsB;AACpB,WAAO,KAAP;AACD;;AACD,QAAM;AAAEc,IAAAA,WAAF;AAAeH,IAAAA;AAAf,MAAyBX,KAA/B;;AACA,MAAI,CAACK,aAAa,CAACS,WAAD,CAAlB,EAAiC;AAC/B,WAAO,KAAP;AACD;;AACD,MAAI,OAAOH,KAAP,KAAkB,WAAlB,IAAgC,CAAC,qBAASA,KAAT,CAArC,EAAsD;AACpD,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD,CAZD;;AAgBA,MAAMI,MAAM,GAAIf,KAAD,IACbS,aAAa,CAACT,KAAD,CAAb,IAAwBa,aAAa,CAACb,KAAD,CADvC;;AAGA,MAAMgB,SAAS,GAAIC,IAAD,IAAsBC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeH,IAAf,CAAX,CAAxC;;AAQA,MAAMI,iCAA+D,GAAG,CACrE,YADqE,EAErE,sBAFqE,EAGrE,mBAHqE,EAIrE,OAJqE,CAAxE;;AAaA,MAAMC,WAAW,GAAOC,EAAJ,IAAmD;AACrE,QAAMC,KAAK,GAAGC,WAAW,CAACC,GAAZ,EAAd;AACA,QAAMC,MAAM,GAAGJ,EAAE,EAAjB;AACA,QAAMK,GAAG,GAAGH,WAAW,CAACC,GAAZ,EAAZ;AAEA,SAAO,CACLC,MADK,EAEL;AACEH,IAAAA,KADF;AAEEI,IAAAA,GAFF;AAGEC,IAAAA,KAAK,EAAED,GAAG,GAAGJ;AAHf,GAFK,CAAP;AAQD,CAbD;;AA4CO,MAAMM,eAAN,CAAsB;AAOpBC,EAAAA,WAAW,CAACd,IAAD,EAAgBe,KAAK,GAAG,KAAxB,EAA+B;AAC/C,QAAI,CAACjB,MAAM,CAACE,IAAD,CAAX,EAAmB;AACjB,YAAM,IAAIgB,KAAJ,CAAW,6CAAX,CAAN;AACD;;AACD,SAAKhB,IAAL,GAAYD,SAAS,CAACC,IAAD,CAArB;AACA,SAAKiB,WAAL,GAAmBzB,aAAa,CAACQ,IAAD,CAAb,GACf,CAAE,YAAF,EAAgB,SAAhB,CADe,GAEf,CAAE,aAAF,CAFJ;AAGA,SAAKkB,iBAAL,GAAyB,KAAKC,aAAL,EAAzB;AACA,SAAKJ,KAAL,GAAaA,KAAb;AACD;;AAEgBK,EAAAA,MAAM,GAAG,CAAC,GAAGC,IAAJ,KAA8B;AACtD,QAAI,KAAKN,KAAT,EAAgB;AACdO,MAAAA,OAAO,CAACC,KAAR,CAAc,GAAGF,IAAjB;AACD;AACF,GAJsB;AAMNG,EAAAA,KAAK,GAAIC,KAAD,IAA2B;AAClD,QAAI,KAAKV,KAAT,EAAgB;AACdO,MAAAA,OAAO,CAACC,KAAR,CAAc,mBAAQ,KAAKvB,IAAb,EAAmB;AAAE0B,QAAAA,KAAK,EAAE;AAAT,OAAnB,CAAd;AACAJ,MAAAA,OAAO,CAACG,KAAR,CAAcA,KAAd;AACD;;AACD,UAAMA,KAAN;AACD,GANqB;AAQLE,EAAAA,aAAa,GAAIC,SAAD,IAC/B,wBAAa,wBAAa,KAAKX,WAAlB,EAA+BW,SAA/B,CAAb,CAD4B;AAGbC,EAAAA,SAAS,GAAID,SAAD,IAAmC;AAC9D,UAAME,MAAM,GAAG,KAAKC,SAAL,CAAe,KAAKJ,aAAL,CAAmBC,SAAnB,CAAf,CAAf;;AACA,QAAI,CAAC9C,YAAY,CAACgD,MAAD,CAAjB,EAA2B;AACzB,aAAO,KAAKN,KAAL,CAAW,IAAIR,KAAJ,CAAW,4BAAX,CAAX,CAAP;AACD;;AACD,WAAOc,MAAP;AACD,GANyB;AAQTX,EAAAA,aAAa,GAAG,MAAgB;AAC/C,UAAMxB,OAAO,GAAG,KAAKoC,SAAL,CAAe,KAAKd,WAApB,CAAhB;;AACA,QAAI,CAAC,qBAAStB,OAAT,CAAL,EAAwB;AACtB,aAAO,KAAK6B,KAAL,CAAW,IAAIR,KAAJ,CAAW,yBAAX,CAAX,CAAP;AACD;;AACD,WAAO1B,MAAM,CAAC0C,IAAP,CAAYrC,OAAZ,CAAP;AACD,GAN6B;AAQbsC,EAAAA,eAAe,GAAG,CACjCC,eADiC,EAEjCzD,IAFiC,EAGjC0D,iBAHiC,KAItB;AACX,UAAMC,KAAe,GAAG,EAAxB;;AACA,QACE,EAACD,iBAAD,aAACA,iBAAD,eAACA,iBAAiB,CAAEE,0BAApB,KACA,CAAC,KAAKnB,iBAAL,CAAuBoB,QAAvB,CAAgCJ,eAAhC,CAFH,EAGE;AACAE,MAAAA,KAAK,CAACG,IAAN,CAAWL,eAAX;AACD;;AACDE,IAAAA,KAAK,CAACG,IAAN,CAAW,GAAG9D,IAAd;AACA,UAAM+D,QAAQ,GAAGJ,KAAK,CAACvD,IAAN,CAAY,GAAZ,CAAjB;AACA,UAAM+C,SAAS,GACb,CAAAO,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,YAAAA,iBAAiB,CAAEM,UAAnB,MAAmC,YAAnC,GACI,4BAAWD,QAAX,CADJ,GAEI,CAAAL,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,YAAAA,iBAAiB,CAAEM,UAAnB,MAAmC,WAAnC,GACA,2BAAUD,QAAV,CADA,GAEA,CAAAL,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,YAAAA,iBAAiB,CAAEM,UAAnB,MAAmC,YAAnC,GACA,2BAAUD,QAAV,CADA,GAEA,CAAAL,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,YAAAA,iBAAiB,CAAEM,UAAnB,MAAmC,YAAnC,GACA,2BAAUD,QAAV,CADA,GAEAA,QATN;;AAUA,QAAI,KAAKrB,aAAL,GAAqBmB,QAArB,CAA8BV,SAA9B,CAAJ,EAA8C;AAC5C,YAAM,IAAIZ,KAAJ,CAAW,wBAAuBY,SAAU,mBAA5C,CAAN;AACD;;AACD,WAAOA,SAAP;AACD,GA5B+B;AA8BfG,EAAAA,SAAS,GAAItD,IAAD,IAC3B,qBAAU,KAAKuB,IAAf,EAAqBvB,IAArB,CADwB;AAGTiE,EAAAA,aAAa,GAC5BjE,IAD+B,IAEW,yBAAc,KAAKuB,IAAnB,EAAyBvB,IAAzB,CAFd;AAIbkE,EAAAA,UAAU,GACzBxE,IAD4B,IAEO;AACnC,UAAMS,OAAO,GAAGR,SAAS,CAACD,IAAD,CAAzB;;AACA,QAAIS,OAAO,CAACL,QAAR,CAAiBqE,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,YAAMC,OAAO,GAAGlE,KAAK,CAAC;AACpBJ,QAAAA,QAAQ,EAAG,EADS;AAEpBE,QAAAA,IAAI,EAAE,wBACJ,KAAKkD,aAAL,CAAmB/C,OAAO,CAACL,QAA3B,CADI,EAEJ,GAAGK,OAAO,CAACH,IAFP;AAFc,OAAD,CAArB;AAOA,aAAO,KAAKkE,UAAL,CAAgBE,OAAO,CAAC1E,IAAxB,CAAP;AACD;;AACD,UAAMkB,KAAK,GAAG,KAAK0C,SAAL,CAAenD,OAAO,CAACH,IAAvB,CAAd;;AACA,QAAIR,KAAK,CAACoB,KAAD,CAAT,EAAkB;AAChB,aAAO,KAAKsD,UAAL,CAAgBtD,KAAK,CAAClB,IAAtB,CAAP;AACD;;AACD,WAAO,CAACkB,KAAD,EAAQlB,IAAR,CAAP;AACD,GAnB0B;AAqBV2E,EAAAA,SAAS,GAAG,CAACrE,IAAD,EAAiBY,KAAjB,KAA0C;AACrE,SAAK+B,MAAL,CAAa,WAAb,EAAyB;AAAE3C,MAAAA,IAAF;AAAQY,MAAAA;AAAR,KAAzB;;AACA,WAAO,qBAAU,KAAKW,IAAf,EAAqBvB,IAArB,EAA2BY,KAA3B,CAAP;AACD,GAHyB;AAKT0D,EAAAA,YAAY,GAAItE,IAAD,IAA0B;AACxD,SAAK2C,MAAL,CAAa,cAAb,EAA4B;AAAE3C,MAAAA;AAAF,KAA5B;;AACA,WAAO,wBAAa,KAAKuB,IAAlB,EAAwBvB,IAAxB,CAAP;AACD,GAH4B;AAKZuE,EAAAA,aAAa,GAC5BC,SAD+B,IAG/B,0BAAc,KAAKjD,IAAnB,EAAyBiD,SAAzB,CAH4B;AAKbC,EAAAA,YAAY,GAAItB,SAAD,IAAgC;AAC9D,UAAMuB,UAAU,GAAG,KAAKxB,aAAL,CAAmBC,SAAnB,CAAnB;AACA,UAAM,CAACsB,YAAD,IAAiB,KAAKF,aAAL,CAAmB,CAAC3D,KAAD,EAAQZ,IAAR,KAAiB;AACzD,UAAI,qBAAUA,IAAV,EAAgB0E,UAAhB,CAAJ,EAAiC;AAC/B,eAAO,KAAP;AACD;;AACD,UAAIlF,KAAK,CAACoB,KAAD,CAAT,EAAkB;AAChB,cAAMT,OAAO,GAAGR,SAAS,CAACiB,KAAK,CAAClB,IAAP,CAAzB;AACA,eACES,OAAO,CAACL,QAAR,CAAiBqE,MAAjB,KAA4B,CAA5B,IACA,2BAAgBO,UAAhB,EAA4BvE,OAAO,CAACH,IAApC,CAFF;AAID;;AACD,aAAO,KAAP;AACD,KAZsB,CAAvB;AAaA,WAAOyE,YAAP;AACD,GAhB4B;AAkBZE,EAAAA,mBAAmB,GAAG,MAAY;AACjD,SAAKhC,MAAL,CAAa,qBAAb;;AACA,QAAIiC,KAAK,GAAG,IAAZ;;AACA,WAAOA,KAAP,EAAc;AACZA,MAAAA,KAAK,GAAG,KAAR;;AACA,WAAK,MAAMzB,SAAX,IAAwB,KAAKT,aAAL,EAAxB,EAA8C;AAC5C,YAAI,CAAC,KAAK+B,YAAL,CAAkBtB,SAAlB,CAAL,EAAmC;AACjC,eAAKmB,YAAL,CAAkB,KAAKpB,aAAL,CAAmBC,SAAnB,CAAlB;AACAyB,UAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF;AACF;AACF,GAbmC;AAenBC,EAAAA,yBAAyB,GAAI1B,SAAD,IAAgC;AAC3E,UAAME,MAAM,GAAG,KAAKD,SAAL,CAAeD,SAAf,CAAf;AACA,UAAMuB,UAAU,GAAG,KAAKxB,aAAL,CAAmBC,SAAnB,CAAnB;AACA,QAAIyB,KAAK,GAAG,KAAZ;AACA,0BAAUvB,MAAV,EAAmBzC,KAAD,IAAW;AAC3B,UAAIpB,KAAK,CAACoB,KAAD,CAAT,EAAkB;AAChB,cAAMT,OAAO,GAAGR,SAAS,CAACiB,KAAK,CAAClB,IAAP,CAAzB;;AACA,YACES,OAAO,CAACL,QAAR,CAAiBqE,MAAjB,KAA4B,CAA5B,IACA,CAAC,2BAAgBO,UAAhB,EAA4BvE,OAAO,CAACH,IAApC,CAFH,EAGE;AACA,gBAAM8E,QAAQ,GAAG,wBAAaJ,UAAb,EAAyB,GAAGvE,OAAO,CAACH,IAApC,CAAjB;AACAY,UAAAA,KAAK,CAAClB,IAAN,GAAaQ,KAAK,CAAC;AAAEJ,YAAAA,QAAQ,EAAG,EAAb;AAAgBE,YAAAA,IAAI,EAAE8E;AAAtB,WAAD,CAAL,CAAwCpF,IAArD;AACAkF,UAAAA,KAAK,GAAG,IAAR;AACD;AACF;AACF,KAZD;AAaA,WAAOA,KAAP;AACD,GAlByC;AAoBzBG,EAAAA,0BAA0B,GAAG,MAAY;AACxD,SAAKpC,MAAL,CAAa,4BAAb;;AACA,QAAIiC,KAAK,GAAG,IAAZ;;AACA,WAAOA,KAAP,EAAc;AACZA,MAAAA,KAAK,GAAG,KAAR;;AACA,WAAK,MAAMzB,SAAX,IAAwB,KAAKT,aAAL,EAAxB,EAA8C;AAC5C,YAAI,KAAKmC,yBAAL,CAA+B1B,SAA/B,CAAJ,EAA+C;AAC7CyB,UAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF;AACF;AACF,GAZ0C;AAc1BI,EAAAA,yBAAyB,GAAG,CAC3CC,aAD2C,EAE3CC,gBAF2C,EAG3CC,aAH2C,KAI/B;AACZ,UAAMC,QAAQ,GAAG,wBACf,KAAKlC,aAAL,CAAmB+B,aAAnB,CADe,EAEf,GAAGC,gBAFY,CAAjB;AAKA,UAAMG,SAAS,GAAG,KAAK/B,SAAL,CAAe8B,QAAf,CAAlB;AACA,UAAMN,QAAQ,GAAG,KAAK5B,aAAL,CAAmBiC,aAAnB,CAAjB;AAEA,UAAM,CAACG,kBAAD,EAAqBC,eAArB,IAAwC,KAAKtB,aAAL,CAAmBa,QAAnB,CAA9C;;AAEA,QAAIQ,kBAAJ,EAAwB;AACtB,UAAI,CAAC,4BAAUD,SAAV,EAAqBE,eAArB,CAAL,EAA4C;AAC1C,aAAKxC,KAAL,CACE,IAAIR,KAAJ,CACG,qBAAoB4C,aAAc,0CADrC,CADF;AAKD;AACF,KARD,MAQO;AACL,WAAKd,SAAL,CAAeS,QAAf,EAAyBO,SAAzB;AACD;;AAED,SAAKhB,SAAL,CAAee,QAAf,EAAyBlF,KAAK,CAAC;AAAEJ,MAAAA,QAAQ,EAAG,EAAb;AAAgBE,MAAAA,IAAI,EAAE8E;AAAtB,KAAD,CAA9B;AAEA,QAAIF,KAAK,GAAG,KAAZ;AACA,0BAAU,KAAKrD,IAAf,EAAsBX,KAAD,IAAW;AAC9B,UAAIpB,KAAK,CAACoB,KAAD,CAAT,EAAkB;AAChB,cAAMT,OAAO,GAAGR,SAAS,CAACiB,KAAK,CAAClB,IAAP,CAAzB;;AACA,YACES,OAAO,CAACL,QAAR,CAAiBqE,MAAjB,KAA4B,CAA5B,IACA,2BAAgBiB,QAAhB,EAA0BjF,OAAO,CAACH,IAAlC,CAFF,EAGE;AACAY,UAAAA,KAAK,CAAClB,IAAN,GAAaQ,KAAK,CAAC;AACjBJ,YAAAA,QAAQ,EAAG,EADM;AAEjBE,YAAAA,IAAI,EAAE,6BAAkBoF,QAAlB,EAA4BN,QAA5B,EAAsC3E,OAAO,CAACH,IAA9C;AAFW,WAAD,CAAL,CAGVN,IAHH;AAIAkF,UAAAA,KAAK,GAAG,IAAR;AACD;AACF;AACF,KAdD;AAeA,WAAOA,KAAP;AACD,GA9CyC;AAgDzBY,EAAAA,4BAA4B,GAAG,CAC9C/B,eAD8C,EAE9CgC,aAF8C,EAG9C/B,iBAH8C,KAIlC;AACZ,QAAIgC,WAAW,GAAG,KAAlB;AACA,QAAId,KAAK,GAAG,IAAZ;;AACA,WAAOA,KAAP,EAAc;AACZA,MAAAA,KAAK,GAAG,KAAR;;AACA,UACEa,aAAa,KAAM,YAAnB,IACAA,aAAa,KAAM,sBADnB,IAEAA,aAAa,KAAM,mBAHrB,EAIE;AACA,cAAMlF,UAAU,GAAG,KAAK6C,SAAL,CAAeK,eAAf,EAAgCgC,aAAhC,CAAnB;;AACA,YAAI,qBAASlF,UAAT,CAAJ,EAA0B;AACxB,eAAK,MAAMoF,CAAX,IAAgB9E,MAAM,CAAC0C,IAAP,CAAYhD,UAAZ,CAAhB,EAAyC;AACvC,kBAAMqF,QAAQ,GAAGrF,UAAU,CAACoF,CAAD,CAA3B;;AACA,gBAAI,CAACnG,KAAK,CAACoG,QAAD,CAAV,EAAsB;AACpB,oBAAMT,aAAa,GAAG,KAAK3B,eAAL,CACpBC,eADoB,EAEpB,CAAE,GAAEkC,CAAE,EAAN,CAFoB,EAGpBjC,iBAHoB,CAAtB;AAKA,mBAAKsB,yBAAL,CACEvB,eADF,EAEE,CAACgC,aAAD,EAAgBE,CAAhB,CAFF,EAGER,aAHF;AAKAP,cAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF;AACF;AACF;;AACD,UAAIa,aAAa,KAAM,OAAvB,EAA+B;AAC7B,cAAMlF,UAAU,GAAG,KAAK6C,SAAL,CAAeK,eAAf,EAAgCgC,aAAhC,CAAnB;;AACA,YAAI,qBAASlF,UAAT,KAAwB,CAACf,KAAK,CAACe,UAAD,CAAlC,EAAgD;AAC9C,gBAAM4E,aAAa,GAAG,KAAK3B,eAAL,CACpBC,eADoB,EAEpB,CAAE,MAAF,CAFoB,EAGpBC,iBAHoB,CAAtB;AAKA,eAAKsB,yBAAL,CACEvB,eADF,EAEE,CAAE,OAAF,CAFF,EAGE0B,aAHF;AAKAP,UAAAA,KAAK,GAAG,IAAR;AACD;AACF;;AACD,UAAIA,KAAJ,EAAW;AACTc,QAAAA,WAAW,GAAG,IAAd;AACD;AACF;;AACD,WAAOA,WAAP;AACD,GAxD4C;AA0D5BG,EAAAA,uBAAuB,GAAG,CACzC1C,SADyC,EAEzC2C,cAFyC,EAGzCpC,iBAHyC,KAI7B;AACZ,QAAIgC,WAAW,GAAG,KAAlB;AACA,QAAId,KAAK,GAAG,IAAZ;;AACA,WAAOA,KAAP,EAAc;AACZA,MAAAA,KAAK,GAAG,KAAR;;AACA,WAAK,MAAMa,aAAX,IAA4BK,cAA5B,EAA4C;AAC1C,YACE,KAAKN,4BAAL,CACErC,SADF,EAEEsC,aAFF,EAGE/B,iBAHF,CADF,EAME;AACAkB,UAAAA,KAAK,GAAG,IAAR;AACD;AACF;;AACD,UAAIA,KAAJ,EAAW;AACTc,QAAAA,WAAW,GAAG,IAAd;AACD;AACF;;AACD,SAAK,MAAMD,aAAX,IAA4BK,cAA5B,EAA4C;AAC1C,UACE,KAAKN,4BAAL,CACErC,SADF,EAEEsC,aAFF,EAGE/B,iBAHF,CADF,EAME;AACA,aAAKmC,uBAAL,CACE1C,SADF,EAEE2C,cAFF,EAGEpC,iBAHF;AAKA,eAAO,IAAP;AACD;AACF;;AACD,WAAOgC,WAAP;AACD,GAzCuC;AA2CvBK,EAAAA,wBAAwB,GAAG,CAC1CD,cAD0C,EAE1CpC,iBAF0C,KAGjC;AACT,SAAKf,MAAL,CAAa,0BAAb;;AACA,QAAIiC,KAAK,GAAG,IAAZ;;AACA,WAAOA,KAAP,EAAc;AACZA,MAAAA,KAAK,GAAG,KAAR;;AACA,WAAK,MAAMzB,SAAX,IAAwB,KAAKT,aAAL,EAAxB,EAA8C;AAC5C,YACE,KAAKmD,uBAAL,CACE1C,SADF,EAEE2C,cAFF,EAGEpC,iBAHF,CADF,EAME;AACAkB,UAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF;AACF;AACF,GArBwC;AAuBxBoB,EAAAA,QAAQ,GAAIC,QAAD,IAA+B;AACzD,UAAM,CAAC5C,MAAD,EAAS6C,QAAT,IAAqB,KAAKhC,UAAL,CAAgB+B,QAAhB,CAA3B;AACA,QAAIP,WAAW,GAAG,KAAlB;AACA,QAAId,KAAK,GAAG,IAAZ;;AACA,WAAOA,KAAP,EAAc;AACZA,MAAAA,KAAK,GAAG,KAAR;AACA,4BAAU,KAAKrD,IAAf,EAAqB,CAACX,KAAD,EAAQZ,IAAR,KAAiB;AACpC,YAAIY,KAAK,KAAKyC,MAAV,IAAoB,4BAAUzC,KAAV,EAAiByC,MAAjB,CAAxB,EAAkD;AAChD,eAAKgB,SAAL,CAAerE,IAAf,EAAqB;AACnBN,YAAAA,IAAI,EAAEwG;AADa,WAArB;AAGAtB,UAAAA,KAAK,GAAG,IAAR;AACD;AACF,OAPD;;AAQA,UAAIA,KAAJ,EAAW;AACTc,QAAAA,WAAW,GAAG,IAAd;AACD;AACF;;AACD,WAAOA,WAAP;AACD,GAnBwB;AAqBRS,EAAAA,SAAS,GAAIC,KAAD,IAA2B;AACtD,QAAIxB,KAAK,GAAG,IAAZ;;AACA,WAAOA,KAAP,EAAc;AACZA,MAAAA,KAAK,GAAG,KAAR;;AACA,WAAK,MAAMlF,IAAX,IAAmB0G,KAAnB,EAA0B;AACxB,YAAI,KAAKJ,QAAL,CAActG,IAAd,CAAJ,EAAyB;AACvBkF,UAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF;AACF;AACF,GAXyB;AAaVyB,EAAAA,oBAAoB,GAAG,CACrCC,IAAsB,GAAG,EADY,KAEN;AAC/B,UAAM,CACJ;AACEvB,MAAAA,0BADF;AAEEgB,MAAAA,wBAFF;AAGEI,MAAAA,SAHF;AAIExB,MAAAA;AAJF,KADI,EAOJ4B,KAPI,IAQF3E,WAAW,CAAC,MAAM;AACpB,YAAM,GAAGmD,0BAAH,IAAiCnD,WAAW,CAAC,MAAM;AACvD,YAAI0E,IAAI,CAACvB,0BAAL,KAAoC,KAAxC,EAA+C;AAC7C;AACD;;AACD,aAAKA,0BAAL;AACD,OALiD,CAAlD;AAOA,YAAM,GAAGoB,SAAH,IAAgBvE,WAAW,CAAC,MAAM;AACtC,YAAI0E,IAAI,CAACH,SAAT,EAAoB;AAClB,eAAKA,SAAL,CAAeG,IAAI,CAACH,SAAL,CAAeK,GAAf,CAAoB/G,GAAD,IAASA,GAAG,CAACC,IAAhC,CAAf;AACD;AACF,OAJgC,CAAjC;;AAMA,WAAKiD,MAAL,CAAY;AAAEwD,QAAAA;AAAF,OAAZ;;AAEA,WAAKxD,MAAL,CAAY;AAAEoC,QAAAA;AAAF,OAAZ;;AAEA,YAAM,GAAGgB,wBAAH,IAA+BnE,WAAW,CAAC,MAAM;AACrD,YAAI0E,IAAI,CAACP,wBAAL,KAAkC,KAAtC,EAA6C;AAC3C;AACD;;AACD,cAAMU,4BAA4B,GAAG,CAACC,KAAK,CAACC,OAAN,CACpCL,IAAI,CAACP,wBAD+B,CAAD,GAGjCpE,iCAHiC,GAIjC2E,IAAI,CAACP,wBAJT;AAKA,aAAKA,wBAAL,CACEU,4BADF,EAEEH,IAAI,CAACM,UAFP;AAID,OAb+C,CAAhD;;AAeA,WAAKjE,MAAL,CAAY;AAAEoD,QAAAA;AAAF,OAAZ;;AAEA,YAAM,GAAGpB,mBAAH,IAA0B/C,WAAW,CAAC,MAAM;AAChD,YAAI0E,IAAI,CAAC3B,mBAAL,KAA6B,KAAjC,EAAwC;AACtC;AACD;;AACD,aAAKA,mBAAL;AACD,OAL0C,CAA3C;;AAOA,WAAKhC,MAAL,CAAY;AAAEgC,QAAAA;AAAF,OAAZ;;AAEA,aAAO;AACLI,QAAAA,0BADK;AAELgB,QAAAA,wBAFK;AAGLI,QAAAA,SAHK;AAILxB,QAAAA;AAJK,OAAP;AAMD,KAlDc,CARf;;AA4DA,SAAKhC,MAAL,CAAY;AAAE4D,MAAAA;AAAF,KAAZ;;AAEA,WAAO;AACLhF,MAAAA,IAAI,EAAE,KAAKA,IADN;AAELsF,MAAAA,OAAO,EAAE;AACP9B,QAAAA,0BADO;AAEPgB,QAAAA,wBAFO;AAGPI,QAAAA,SAHO;AAIPxB,QAAAA,mBAJO;AAKP4B,QAAAA;AALO;AAFJ,KAAP;AAUD,GA3EmC;AA6EpBO,EAAAA,SAAS,GAAG,CAACR,IAAsB,GAAG,EAA1B,KAC1B,KAAKD,oBAAL,CAA0BC,IAA1B,EAAgC/E,IADT;AA3dE","sourcesContent":["import { inspect } from \"util\";\n\nimport { camelCase, pascalCase, snakeCase, paramCase } from \"change-case\";\nimport deepEqual from \"fast-deep-equal\";\n\nimport {\n  deleteAtPath,\n  equalPath,\n  getAtPath,\n  getAtPathSafe,\n  getChildPath,\n  matchPathPrefix,\n  replacePathPrefix,\n  setAtPath,\n} from \"./Path\";\nimport { findFirstDeep, isRecord, visitDeep } from \"./util\";\n\ntype Ref = {\n  $ref: string;\n};\n\nconst isRef = (ref: unknown): ref is Ref => {\n  if (!isRecord(ref)) {\n    return false;\n  }\n  return typeof ref.$ref === `string`;\n};\n\ntype RefPath = {\n  readonly basePath: string;\n  readonly path: string[];\n};\n\nconst toRefPath = ($ref: string): RefPath => {\n  const indexOfPath = $ref.indexOf(`#`);\n  return {\n    basePath: $ref.slice(0, indexOfPath),\n    path: $ref\n      .slice(indexOfPath + 1)\n      .split(`/`)\n      .slice(1),\n  };\n};\n\nconst toRef = (refPath: RefPath): Ref => ({\n  $ref: [`${refPath.basePath}#`, ...refPath.path].join(`/`),\n});\n\ntype SpecSchema = {\n  readonly properties?: Record<string, unknown>;\n  readonly additionalProperties?: boolean | Record<string, unknown>;\n  readonly patternProperties?: Record<string, unknown>;\n  readonly items?: Record<string, unknown>;\n};\n\nconst isSpecSchema = (input: unknown): input is SpecSchema => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  const { properties, additionalProperties, patternProperties, items } = input;\n  if (typeof properties !== `undefined` && !isRecord(properties)) {\n    return false;\n  }\n\n  if (\n    typeof additionalProperties !== `undefined` &&\n    typeof additionalProperties !== `boolean` &&\n    !isRecord(additionalProperties)\n  ) {\n    return false;\n  }\n\n  if (\n    typeof patternProperties !== `undefined` &&\n    typeof patternProperties !== `boolean` &&\n    !isRecord(patternProperties)\n  ) {\n    return false;\n  }\n\n  if (typeof items !== `undefined` && !isRecord(items)) {\n    return false;\n  }\n\n  return true;\n};\n\ntype SpecSchemas = Record<string, SpecSchema>;\n\nconst isSpecSchemas = (input: unknown): input is SpecSchemas => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  for (const value of Object.values(input)) {\n    if (!isSpecSchema(value)) {\n      return false;\n    }\n  }\n  return true;\n};\n\ntype OpenApiSpec = {\n  readonly components: {\n    readonly schemas: SpecSchemas;\n  };\n  readonly paths?: Record<string, unknown>;\n};\n\nconst isOpenApiSpec = (input: unknown): input is OpenApiSpec => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  const { components, paths } = input;\n  if (!isRecord(components)) {\n    return false;\n  }\n  const { schemas } = components;\n  if (!isSpecSchemas(schemas)) {\n    return false;\n  }\n  if (typeof paths !== `undefined` && !isRecord(paths)) {\n    return false;\n  }\n  return true;\n};\n\ntype SwaggerSpec = {\n  readonly definitions: SpecSchemas;\n  readonly paths?: Record<string, unknown>;\n};\n\nconst isSwaggerSpec = (input: unknown): input is SwaggerSpec => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  const { definitions, paths } = input;\n  if (!isSpecSchemas(definitions)) {\n    return false;\n  }\n  if (typeof paths !== `undefined` && !isRecord(paths)) {\n    return false;\n  }\n  return true;\n};\n\nexport type Spec = OpenApiSpec | SwaggerSpec;\n\nconst isSpec = (input: unknown): input is Spec =>\n  isOpenApiSpec(input) || isSwaggerSpec(input);\n\nconst deepClone = (spec: Spec): Spec => JSON.parse(JSON.stringify(spec));\n\ntype ExtractSchemaPropertiesKey =\n  | `properties`\n  | `additionalProperties`\n  | `patternProperties`\n  | `items`;\n\nconst defaultExtractSchemaPropertiesKey: ExtractSchemaPropertiesKey[] = [\n  `properties`,\n  `additionalProperties`,\n  `patternProperties`,\n  `items`,\n];\n\ntype Timings = {\n  readonly begin: number;\n  readonly end: number;\n  readonly delta: number;\n};\n\nconst withTimings = <T>(fn: () => T): [result: T, timings: Timings] => {\n  const begin = performance.now();\n  const result = fn();\n  const end = performance.now();\n\n  return [\n    result,\n    {\n      begin,\n      end,\n      delta: end - begin,\n    },\n  ];\n};\n\ntype TransformWithTimingsResult = {\n  readonly spec: Spec;\n  readonly timings: {\n    readonly rewriteSchemasAbsoluteRefs: Timings;\n    readonly extractSchemasProperties: Timings;\n    readonly mergeRefs: Timings;\n    readonly deleteUnusedSchemas: Timings;\n    readonly total: Timings;\n  };\n};\n\ntype SchemaKeysOptions = {\n  readonly removeInitialSchemasPrefix?: boolean;\n  readonly changeCase?:\n    | `preserve`\n    | `camelCase`\n    | `PascalCase`\n    | `snake_case`\n    | `param-case`;\n};\n\nexport type TransformOptions = {\n  readonly rewriteSchemasAbsoluteRefs?: boolean;\n  readonly extractSchemasProperties?: boolean | ExtractSchemaPropertiesKey[];\n  readonly mergeRefs?: Ref[];\n  readonly deleteUnusedSchemas?: boolean;\n  readonly schemaKeys?: SchemaKeysOptions;\n};\n\nexport class SpecTransformer {\n  private readonly DEBUG: boolean;\n  private readonly spec: Spec;\n  private readonly initialSchemaKeys: string[];\n\n  private readonly schemasPath: string[];\n\n  public constructor(spec: unknown, DEBUG = false) {\n    if (!isSpec(spec)) {\n      throw new Error(`spec is not an OpenApiSpec or a SwaggerSpec`);\n    }\n    this.spec = deepClone(spec);\n    this.schemasPath = isOpenApiSpec(spec)\n      ? [`components`, `schemas`]\n      : [`definitions`];\n    this.initialSchemaKeys = this.getSchemaKeys();\n    this.DEBUG = DEBUG;\n  }\n\n  private readonly _DEBUG = (...args: unknown[]): void => {\n    if (this.DEBUG) {\n      console.debug(...args);\n    }\n  };\n\n  private readonly throw = (error: unknown): never => {\n    if (this.DEBUG) {\n      console.debug(inspect(this.spec, { depth: null }));\n      console.error(error);\n    }\n    throw error;\n  };\n\n  private readonly getSchemaPath = (schemaKey: string): string[] =>\n    getChildPath(getChildPath(this.schemasPath, schemaKey));\n\n  private readonly getSchema = (schemaKey: string): SpecSchema => {\n    const schema = this.getAtPath(this.getSchemaPath(schemaKey));\n    if (!isSpecSchema(schema)) {\n      return this.throw(new Error(`schema is not a SpecSchema`));\n    }\n    return schema;\n  };\n\n  private readonly getSchemaKeys = (): string[] => {\n    const schemas = this.getAtPath(this.schemasPath);\n    if (!isRecord(schemas)) {\n      return this.throw(new Error(`schemas is not a Record`));\n    }\n    return Object.keys(schemas);\n  };\n\n  private readonly createSchemaKey = (\n    parentSchemaKey: string,\n    path: string[],\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): string => {\n    const parts: string[] = [];\n    if (\n      !schemaKeysOptions?.removeInitialSchemasPrefix ||\n      !this.initialSchemaKeys.includes(parentSchemaKey)\n    ) {\n      parts.push(parentSchemaKey);\n    }\n    parts.push(...path);\n    const baseName = parts.join(`_`);\n    const schemaKey =\n      schemaKeysOptions?.changeCase === `PascalCase`\n        ? pascalCase(baseName)\n        : schemaKeysOptions?.changeCase === `camelCase`\n        ? camelCase(baseName)\n        : schemaKeysOptions?.changeCase === `param-case`\n        ? paramCase(baseName)\n        : schemaKeysOptions?.changeCase === `snake_case`\n        ? snakeCase(baseName)\n        : baseName;\n    if (this.getSchemaKeys().includes(schemaKey)) {\n      throw new Error(`schemaKey(schemaKey='${schemaKey}') already exists`);\n    }\n    return schemaKey;\n  };\n\n  private readonly getAtPath = (path: string[]): unknown =>\n    getAtPath(this.spec, path);\n\n  private readonly getAtPathSafe = (\n    path: string[],\n  ): [valueFound: boolean, value: unknown] => getAtPathSafe(this.spec, path);\n\n  private readonly resolveRef = (\n    $ref: string,\n  ): [value: unknown, $ref: string] => {\n    const refPath = toRefPath($ref);\n    if (refPath.basePath.length > 0) {\n      const nextRef = toRef({\n        basePath: ``,\n        path: getChildPath(\n          this.getSchemaPath(refPath.basePath),\n          ...refPath.path,\n        ),\n      });\n      return this.resolveRef(nextRef.$ref);\n    }\n    const value = this.getAtPath(refPath.path);\n    if (isRef(value)) {\n      return this.resolveRef(value.$ref);\n    }\n    return [value, $ref];\n  };\n\n  private readonly setAtPath = (path: string[], value: unknown): void => {\n    this._DEBUG(`setAtPath`, { path, value });\n    return setAtPath(this.spec, path, value);\n  };\n\n  private readonly deleteAtPath = (path: string[]): void => {\n    this._DEBUG(`deleteAtPath`, { path });\n    return deleteAtPath(this.spec, path);\n  };\n\n  private readonly findFirstDeep = (\n    predicate: (value: unknown, path: string[]) => boolean,\n  ): [found: boolean, value: unknown, path: string[]] =>\n    findFirstDeep(this.spec, predicate);\n\n  private readonly hasProperRef = (schemaKey: string): boolean => {\n    const schemaPath = this.getSchemaPath(schemaKey);\n    const [hasProperRef] = this.findFirstDeep((value, path) => {\n      if (equalPath(path, schemaPath)) {\n        return false;\n      }\n      if (isRef(value)) {\n        const refPath = toRefPath(value.$ref);\n        return (\n          refPath.basePath.length === 0 &&\n          matchPathPrefix(schemaPath, refPath.path)\n        );\n      }\n      return false;\n    });\n    return hasProperRef;\n  };\n\n  private readonly deleteUnusedSchemas = (): void => {\n    this._DEBUG(`deleteUnusedSchemas`);\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const schemaKey of this.getSchemaKeys()) {\n        if (!this.hasProperRef(schemaKey)) {\n          this.deleteAtPath(this.getSchemaPath(schemaKey));\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  private readonly rewriteSchemaAbsoluteRefs = (schemaKey: string): boolean => {\n    const schema = this.getSchema(schemaKey);\n    const schemaPath = this.getSchemaPath(schemaKey);\n    let dirty = false;\n    visitDeep(schema, (value) => {\n      if (isRef(value)) {\n        const refPath = toRefPath(value.$ref);\n        if (\n          refPath.basePath.length === 0 &&\n          !matchPathPrefix(schemaPath, refPath.path)\n        ) {\n          const nextPath = getChildPath(schemaPath, ...refPath.path);\n          value.$ref = toRef({ basePath: ``, path: nextPath }).$ref;\n          dirty = true;\n        }\n      }\n    });\n    return dirty;\n  };\n\n  private readonly rewriteSchemasAbsoluteRefs = (): void => {\n    this._DEBUG(`rewriteSchemasAbsoluteRefs`);\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const schemaKey of this.getSchemaKeys()) {\n        if (this.rewriteSchemaAbsoluteRefs(schemaKey)) {\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  private readonly extractSchemaPathAsSchema = (\n    prevSchemaKey: string,\n    prevRelativePath: string[],\n    nextSchemaKey: string,\n  ): boolean => {\n    const prevPath = getChildPath(\n      this.getSchemaPath(prevSchemaKey),\n      ...prevRelativePath,\n    );\n\n    const prevValue = this.getAtPath(prevPath);\n    const nextPath = this.getSchemaPath(nextSchemaKey);\n\n    const [hasValueAtNextPath, valueAtNextPath] = this.getAtPathSafe(nextPath);\n\n    if (hasValueAtNextPath) {\n      if (!deepEqual(prevValue, valueAtNextPath)) {\n        this.throw(\n          new Error(\n            `schema(schemaKey='${nextSchemaKey}') already exists with a different value`,\n          ),\n        );\n      }\n    } else {\n      this.setAtPath(nextPath, prevValue);\n    }\n\n    this.setAtPath(prevPath, toRef({ basePath: ``, path: nextPath }));\n\n    let dirty = false;\n    visitDeep(this.spec, (value) => {\n      if (isRef(value)) {\n        const refPath = toRefPath(value.$ref);\n        if (\n          refPath.basePath.length === 0 &&\n          matchPathPrefix(prevPath, refPath.path)\n        ) {\n          value.$ref = toRef({\n            basePath: ``,\n            path: replacePathPrefix(prevPath, nextPath, refPath.path),\n          }).$ref;\n          dirty = true;\n        }\n      }\n    });\n    return dirty;\n  };\n\n  private readonly extractSchemaPropertiesAtKey = (\n    parentSchemaKey: string,\n    propertiesKey: ExtractSchemaPropertiesKey,\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): boolean => {\n    let globalDirty = false;\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      if (\n        propertiesKey === `properties` ||\n        propertiesKey === `additionalProperties` ||\n        propertiesKey === `patternProperties`\n      ) {\n        const properties = this.getSchema(parentSchemaKey)[propertiesKey];\n        if (isRecord(properties)) {\n          for (const k of Object.keys(properties)) {\n            const property = properties[k];\n            if (!isRef(property)) {\n              const nextSchemaKey = this.createSchemaKey(\n                parentSchemaKey,\n                [`${k}`],\n                schemaKeysOptions,\n              );\n              this.extractSchemaPathAsSchema(\n                parentSchemaKey,\n                [propertiesKey, k],\n                nextSchemaKey,\n              );\n              dirty = true;\n              break;\n            }\n          }\n        }\n      }\n      if (propertiesKey === `items`) {\n        const properties = this.getSchema(parentSchemaKey)[propertiesKey];\n        if (isRecord(properties) && !isRef(properties)) {\n          const nextSchemaKey = this.createSchemaKey(\n            parentSchemaKey,\n            [`item`],\n            schemaKeysOptions,\n          );\n          this.extractSchemaPathAsSchema(\n            parentSchemaKey,\n            [`items`],\n            nextSchemaKey,\n          );\n          dirty = true;\n        }\n      }\n      if (dirty) {\n        globalDirty = true;\n      }\n    }\n    return globalDirty;\n  };\n\n  private readonly extractSchemaProperties = (\n    schemaKey: string,\n    propertiesKeys: ExtractSchemaPropertiesKey[],\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): boolean => {\n    let globalDirty = false;\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const propertiesKey of propertiesKeys) {\n        if (\n          this.extractSchemaPropertiesAtKey(\n            schemaKey,\n            propertiesKey,\n            schemaKeysOptions,\n          )\n        ) {\n          dirty = true;\n        }\n      }\n      if (dirty) {\n        globalDirty = true;\n      }\n    }\n    for (const propertiesKey of propertiesKeys) {\n      if (\n        this.extractSchemaPropertiesAtKey(\n          schemaKey,\n          propertiesKey,\n          schemaKeysOptions,\n        )\n      ) {\n        this.extractSchemaProperties(\n          schemaKey,\n          propertiesKeys,\n          schemaKeysOptions,\n        );\n        return true;\n      }\n    }\n    return globalDirty;\n  };\n\n  private readonly extractSchemasProperties = (\n    propertiesKeys: ExtractSchemaPropertiesKey[],\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): void => {\n    this._DEBUG(`extractSchemasProperties`);\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const schemaKey of this.getSchemaKeys()) {\n        if (\n          this.extractSchemaProperties(\n            schemaKey,\n            propertiesKeys,\n            schemaKeysOptions,\n          )\n        ) {\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  private readonly mergeRef = (prev$ref: string): boolean => {\n    const [schema, next$ref] = this.resolveRef(prev$ref);\n    let globalDirty = false;\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      visitDeep(this.spec, (value, path) => {\n        if (value !== schema && deepEqual(value, schema)) {\n          this.setAtPath(path, {\n            $ref: next$ref,\n          });\n          dirty = true;\n        }\n      });\n      if (dirty) {\n        globalDirty = true;\n      }\n    }\n    return globalDirty;\n  };\n\n  private readonly mergeRefs = ($refs: string[]): void => {\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const $ref of $refs) {\n        if (this.mergeRef($ref)) {\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  public readonly transformWithTimings = (\n    opts: TransformOptions = {},\n  ): TransformWithTimingsResult => {\n    const [\n      {\n        rewriteSchemasAbsoluteRefs,\n        extractSchemasProperties,\n        mergeRefs,\n        deleteUnusedSchemas,\n      },\n      total,\n    ] = withTimings(() => {\n      const [, rewriteSchemasAbsoluteRefs] = withTimings(() => {\n        if (opts.rewriteSchemasAbsoluteRefs === false) {\n          return;\n        }\n        this.rewriteSchemasAbsoluteRefs();\n      });\n\n      const [, mergeRefs] = withTimings(() => {\n        if (opts.mergeRefs) {\n          this.mergeRefs(opts.mergeRefs.map((ref) => ref.$ref));\n        }\n      });\n\n      this._DEBUG({ mergeRefs });\n\n      this._DEBUG({ rewriteSchemasAbsoluteRefs });\n\n      const [, extractSchemasProperties] = withTimings(() => {\n        if (opts.extractSchemasProperties === false) {\n          return;\n        }\n        const extractSchemasPropertiesKeys = !Array.isArray(\n          opts.extractSchemasProperties,\n        )\n          ? defaultExtractSchemaPropertiesKey\n          : opts.extractSchemasProperties;\n        this.extractSchemasProperties(\n          extractSchemasPropertiesKeys,\n          opts.schemaKeys,\n        );\n      });\n\n      this._DEBUG({ extractSchemasProperties });\n\n      const [, deleteUnusedSchemas] = withTimings(() => {\n        if (opts.deleteUnusedSchemas === false) {\n          return;\n        }\n        this.deleteUnusedSchemas();\n      });\n\n      this._DEBUG({ deleteUnusedSchemas });\n\n      return {\n        rewriteSchemasAbsoluteRefs,\n        extractSchemasProperties,\n        mergeRefs,\n        deleteUnusedSchemas,\n      };\n    });\n\n    this._DEBUG({ total });\n\n    return {\n      spec: this.spec,\n      timings: {\n        rewriteSchemasAbsoluteRefs,\n        extractSchemasProperties,\n        mergeRefs,\n        deleteUnusedSchemas,\n        total,\n      },\n    };\n  };\n\n  public readonly transform = (opts: TransformOptions = {}): Spec =>\n    this.transformWithTimings(opts).spec;\n}\n"],"file":"SpecTransformer.js"}