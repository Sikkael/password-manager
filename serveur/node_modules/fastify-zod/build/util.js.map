{"version":3,"sources":["../src/util.ts"],"names":["isZod","Type","input","parse","ZodShape","shape","z","object","strict","isRecord","Array","isArray","mapDeep","current","replace","k","length","Object","keys","findFirstDeep","predicate","path","push","found","value","pop","visitDeep","visit"],"mappings":"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","sourcesContent":["import { ZodSchema, ZodType, z } from \"zod\";\n\nexport const isZod =\n  <T>(Type: ZodType<T>) =>\n  (input: unknown): input is T => {\n    try {\n      Type.parse(input);\n      return true;\n    } catch {\n      return false;\n    }\n  };\nexport type ZodShape<T> = {\n  // Require all the keys from T\n  [key in keyof T]-?: undefined extends T[key]\n    ? // When optional, require the type to be optional in zod\n      z.ZodOptionalType<z.ZodType<T[key]>>\n    : z.ZodType<T[key]>;\n};\n\nexport const ZodShape = <T>(shape: ZodShape<T>): ZodSchema<T> =>\n  z.object(shape).strict() as unknown as ZodSchema<T>;\n\nexport const isRecord = (input: unknown): input is Record<string, unknown> =>\n  !Array.isArray(input) && typeof input === `object` && input !== null;\n\nexport const mapDeep = (\n  current: unknown,\n  replace: (value: unknown) => void,\n): unknown => {\n  if (Array.isArray(current)) {\n    for (let k = 0; k < current.length; k++) {\n      current[k] = replace(mapDeep(current[k], replace));\n    }\n  } else if (isRecord(current)) {\n    for (const k of Object.keys(current)) {\n      current[k] = replace(mapDeep(current[k], replace));\n    }\n  }\n  return current;\n};\n\nexport const findFirstDeep = (\n  current: unknown,\n  predicate: (value: unknown, path: string[]) => boolean,\n  path: string[] = [],\n): [found: boolean, value: unknown, path: string[]] => {\n  if (predicate(current, path)) {\n    return [true, current, path];\n  }\n  if (Array.isArray(current)) {\n    for (let k = 0; k < current.length; k++) {\n      path.push(`${k}`);\n      const [found, value] = findFirstDeep(current[k], predicate, path);\n      if (found) {\n        return [found, value, path];\n      }\n      path.pop();\n    }\n    return [false, null, []];\n  }\n  if (isRecord(current)) {\n    for (const k of Object.keys(current)) {\n      path.push(k);\n      const [found, value] = findFirstDeep(current[k], predicate, path);\n      if (found) {\n        return [found, value, path];\n      }\n      path.pop();\n    }\n    return [false, null, []];\n  }\n  return [false, null, []];\n};\n\nexport const visitDeep = (\n  current: unknown,\n  visit: (value: unknown, path: string[]) => void,\n  path: string[] = [],\n): void => {\n  visit(current, path);\n  if (Array.isArray(current)) {\n    for (let k = 0; k < current.length; k++) {\n      path.push(`${k}`);\n      visitDeep(current[k], visit, path);\n      path.pop();\n    }\n    return;\n  }\n  if (isRecord(current)) {\n    for (const k of Object.keys(current)) {\n      path.push(k);\n      visitDeep(current[k], visit, path);\n      path.pop();\n    }\n    return;\n  }\n  return;\n};\n"],"file":"util.js"}